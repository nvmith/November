## 사석훈
처음에 정렬 한 뒤 좌우좌우 넣어서 새로운 리스트를 만들었는데 리팩토링을 위해 자료를 찾던 도중 새로운 리스트에 넣는 방법을 건너뛰고 2칸씩 띄워서 차이를 계산하는 방법도 있다는 사실을 깨달았다
## 지용주
처음에 문제를 풀 때는 그냥 쉽게 생각나는 대로 쭉쭉 풀었다. 생각나는 대로 풀어서 그런지 코드가 조금 더러웠다. 그리디 알고리즘에 맞게 탐욕적 해답을 찾아보니 훨씬 간단하게 코드를 짤 수 있었다. 처음에는 원하는 대로 새로운 리스트를 만들었는데 그런 방법이 아닌 정렬한 후 두칸씩 띄워서 차이를 계산하는 방법이 있다는 것을 알고 이 방향대로 최적화를 진행했다.
## 최이승우
처음에는 정렬된 배열을 기준으로 덱에 양옆으로 번갈아 배치한 뒤, 인접 원소들의 차이 중 최댓값을 구하는 방식으로 난이도를 계산했다.
하지만 이 과정을 분석해 보니 실제로는 인접한 원소들이 항상 정렬된 배열에서 두 칸 떨어진 값들이 되므로, 곧바로 a[i+2] - a[i]의 최댓값만 구하면 동일한 결과를 얻을 수 있었다.
따라서 덱을 사용할 필요가 없어지고 정렬 후 두 칸 간격의 차이 최댓값을 구하는 방식으로 최적화할 수 있었다.
